#!/usr/bin/env perl

use 5.16.0;
use warnings;
use Data::Dumper;

# Expands macros within $s using definitions in $def.
# Undefined macros are replaced with $default, if given.  Otherwise,
# they are left unexpanded.
sub expand {
    my ($s, $def, $default) = @_;

    my $repl = sub {
        my $k = shift;
        return defined $default ? $default : $& unless exists $def->{$k};
        return expand($def->{$k}, $def);
    };

    # Replace all macro references with output of repl().
    return $s =~ s/\$\{([\w_.]+)\}/$repl->($1)/ger;
}

# Reads variable definitions from a makefile.
sub read_mk_vars {
    my $path = shift;
    open(my $fh, '<', $path) or die "Can't open $path: $!";
    my $mk = do { local $/; <$fh> };

    # Join escaped newlines.
    $mk =~ s/\\\n//g;

    # Extract variable definitions.
    my %var = $mk =~ /^([\w.]+) \s* = \s* (.*?) \s* $/xmg;

    # Expand macros in values.
    while (my ($k, $v) = each %var) {
        $var{$k} = expand($v, \%var);
    }

    return %var;
}

# Emits target line with optional dependencies.
sub target {
    my ($target, @deps) = @_;
    print "\n";
    say join " ", "$target:", @deps;
}

# Emits rule line.
sub rule {
    print "\t";
    say join " ", grep /\S/, @_;
}

# Appends to a variable's value.
sub appendvar {
    my ($var, @val) = @_;
    print "\n";
    say "$var += $_" for @val;
}

# Convert pathname to makefile variable name.
sub path2var {
    my $path = shift;
    my $var  = $path =~ s/\.\w+$//r;
    $var =~ s|/|.|g;
    $var =~ s/[^\w.]/_/g;
    return uc $var;
}

my $makefile = shift or die "No makefile given";

my %mkvar = read_mk_vars($makefile);
my $CC    = $ENV{CC} || 'cc';
my @lib   = split " ", $mkvar{'src.lib'};
my @pyx   = split " ", $mkvar{'py.pyx'};

say "# auto-generated by auto.pl";

for my $src (@lib) {
    $src =~ m|^src/(.+)\.c$|;
    my $obj = "\$b/$1.o";
    my $mod = path2var $1;

    my $cflags = expand("\${CFLAGS} \${CFLAGS_$mod}", \%mkvar, "");

    print "\n";

    # Call compiler to get dependencies.
    print qx!$CC $cflags -Isrc -MT '$obj' -MM '$src'!;

    # Build .o
    target $obj;
    rule '@mkdir -p ${@D}';
    rule '${CC} ${CFLAGS}', "\${CFLAGS_$mod}", '-c -o $@', $src;

    # Add as a library dependency.
    target '$b/libcoho.a', $obj;
}

for my $pyx (@pyx) {
    $pyx =~ m|^python/coho/(.+).pyx$|;
    my $x   = $1;
    my $c   = "\$b/python/coho/$x.c";
    my $o   = "\$b/python/coho/$x.o";
    my $so  = "\$b/python/coho/$x.so";
    my $pyi = "\$b/python/coho/$x.pyi";
    my $mod = path2var $x;

    # Build .c
    target $c, $pyx;
    rule '@mkdir -p ${@D}';
    rule '${CYTHON} ${CYTHON_FLAGS}', "\${CYTHON_FLAGS.$mod}",
      '-Ipython -o $@', $pyx;

    # Build .o
    target $o, $c;
    rule '${CC} ${CFLAGS_PY}', "\${CFLAGS_PY.$mod} -Isrc -o \$@ -c $c";

    # Build .so
    target $so, $o, '$b/libcoho.a';
    rule '${CC} -shared -o $@', $o, '$b/libcoho.a';

    # Build .pyi
    target $pyi, "python/coho/$x.pyi";
    rule '@mkdir -p ${@D}';
    rule "install -m0644 python/coho/$x.pyi", '$@';

    # Save to lists.
    appendvar 'py.c',   $c;
    appendvar 'py.o',   $o;
    appendvar 'py.so',  $so;
    appendvar 'py.pyi', $pyi;
    appendvar 'py.obj', $c, $o, $so, $pyi;
}
